from __future__ import division
import pyomo.environ as pyo
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

class PID_Controller():
  def __init__(self):
    # Initialize Default Gains
    self.Kp = 1
    self.Ki = 1
    self.Kd = 1

    pass

  def setProportionalGain(self,P):
    pass

  def setIntegralGain(self,I):
    pass

  def setDerivativeGain(self,D):
    pass

  def setIntegralWindupMode(self,mode):
    pass

  def computeControlInput(self):
    pass

class MPC_Controller():
  def __init__(self):
    pass


def thermoElectricTempControlModel(Ts, x, u):
  # Model Constant Values
  C_Fluid = 800
  C_Reservoir = 1000
  C_HEXplate = 600

  R_Fluid_Ambient = 10
  R_Reservoir_Ambient = 3
  R_HEXplate_Ambient = 1
  R_Fluid_Reservoir = 0.5

  T_Ambient = 23

  R_TEC = 0.02              # Electrical Resistance of Thermoelectric device in Ohms
  alpha_TEC = 220 * 10**-6  # Seebeck Coefficient of TEC in V/Kelvin
  K_TEC = 1.5 * 10**-3      # Thermal Conductance of TEC between hot and cold side
  qmax_HEX = 80             # Maximum Cooling capability of Heat exchanger in Watts

  # State Variables
  T_Fluid = x[0]
  T_Reservoir = x[1]
  T_HEXplate = x[2]

  # Control Inputs
  V_TEC = u[0]                                              # Voltage Applied to TEC module
  q_HEX = min(u[1]*(T_HEXplate - T_Ambient)/0.01,qmax_HEX)  # Liquid to Ambient Heat Exchanger

  # Heat Flowrates
  q_Fluid_Ambient = (T_Fluid - T_Ambient)/R_Fluid_Ambient
  q_Reservoir_Ambient = (T_Reservoir - T_Ambient)/R_Reservoir_Ambient
  q_HEXplate_Ambient = (T_HEXplate - T_Ambient)/R_HEXplate_Ambient
  q_Fluid_Reservoir = (T_Reservoir - T_Fluid)/R_Fluid_Reservoir
  q_Reservoir_Fluid = -q_Fluid_Reservoir
  q_TEC_Reservoir =  alpha_TEC*T_Reservoir*V_TEC/R_TEC - 0.5*V_TEC**2/R_TEC + K_TEC*(T_Reservoir - T_HEXplate) # From Mathworks documentation of TEC modeling
  q_TEC_HEXplate = -alpha_TEC*T_HEXplate*V_TEC/R_TEC - 0.5*V_TEC**2/R_TEC + K_TEC*(T_HEXplate - T_Reservoir)

  # State Derivatives
  Tdot_Fluid = 1/C_Fluid*(-q_Fluid_Ambient + q_Fluid_Reservoir)
  Tdot_Reservoir = 1/C_Reservoir*(q_Fluid_Reservoir - q_Reservoir_Ambient - q_TEC_Reservoir)
  Tdot_HEXplate = 1/C_HEXplate*(q_HEXplate_Ambient - q_TEC_HEXplate - q_HEX)

  # Euler Discritization and Caluclation of Next State
  x_next = np.zeros((1,3))
  x_next[0,0] = Ts*Tdot_Fluid + T_Fluid
  x_next[0,1] = Ts*Tdot_Reservoir + T_Reservoir
  x_next[0,2] = Ts*Tdot_HEXplate + T_HEXplate
  x_next= np.array(x_next)

  return x_next

def plotResults(t,x):
  fig = plt.figure(figsize=(9,5));
  plt.subplot(1,3,1)
  plt.plot(t,x[:,0])
  plt.subplot(1,3,2)
  plt.plot(t,x[:,1])
  plt.subplot(1,3,3)
  plt.plot(t,x[:,2])
  plt.show()

def generateTrajectory(Times,Temperatures,Ts):
  Duration = Times[-1] - Times[0]
  numPoints = round(Duration/Ts)
  f = interpolate.interp1d(Times,Temperatures,'linear')
  tGrid = np.linspace(Times[0], Times[-1], numPoints+1)
  TGrid = f(tGrid)
  return tGrid, TGrid

N = 50
Ts = 5

u = np.zeros((N,2))
for k in range(N):
  if k < 150:
    input = np.array([0,1])
  if k < 100:
    input = np.array([-5,1])
  if k < 50:
    input = np.array([-5,0])
  u[k,:] = input

x0 = np.ones((1,3))*23
x = x0
t = np.linspace(0,N*Ts,N+1)/60


for k in range(N):
  x_next = thermoElectricTempControlModel(Ts,x[k,:],u[k,:])
  x = np.append(x,x_next,axis=0)

#I will implement an MPC controller after thursday. Shouldn't take too long.

plotResults(t,x)

timePoints = [0, 300, 900, 1200, 1800, 2100]
TempPoints = [23, 23, 65, 65, 23, 23]

t,Setpoint = generateTrajectory(timePoints,TempPoints,Ts)

plt.figure()
plt.plot(t,Setpoint,'b*')
plt.show()
